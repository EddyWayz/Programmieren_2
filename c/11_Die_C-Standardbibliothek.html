<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 11: Die C-Standardbibliothek</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="index.html">C</a>
    <a href="../cpp/index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 11: Die C-Standardbibliothek</h1>
        <p>Den professionellen Werkzeugkasten von C meisterhaft einsetzen.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Am Ende dieser Einheit kennst und nutzt du die wichtigsten Funktionen der C-Standardbibliothek. Du kannst Zeichenketten sicher manipulieren (<strong><code>string.h</code></strong>), Zufallszahlen erzeugen und Strings in Zahlen umwandeln (<strong><code>stdlib.h</code></strong>), komplexe mathematische Berechnungen durchf√ºhren (<strong><code>math.h</code></strong>) und die Ausf√ºhrungszeit von Codeabschnitten messen (<strong><code>time.h</code></strong>). Du verstehst, warum die Nutzung dieser Standardfunktionen der Neuerfindung des Rads vorzuziehen ist.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Ein guter Handwerker baut nicht jedes Mal seinen Hammer selbst ‚Äì er hat einen Koffer mit erprobten, verl√§sslichen Werkzeugen. Die C-Standardbibliothek ist genau das: ein Satz von Header-Dateien und Funktionen, die f√ºr grundlegende Aufgaben wie String-Manipulation, mathematische Berechnungen oder Speicherverwaltung optimiert, getestet und auf jeder C-konformen Plattform verf√ºgbar sind.
            </p>
            <p>
                Die Kenntnis dieser Bibliotheken trennt den Anf√§nger vom fortgeschrittenen Programmierer. Sie erm√∂glicht es dir, dich auf die eigentliche Logik deines Problems zu konzentrieren, anstatt grundlegende Funktionalit√§t immer wieder neu zu implementieren. Das Ergebnis ist k√ºrzerer, lesbarerer, sichererer und portablerer Code.
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>Standardbibliothek</h4>
                <p>Die Menge an vordefinierten Funktionen und Typen, die durch den C-Standard festgelegt und von jedem C-Compiler bereitgestellt werden muss.  Der Zugriff erfolgt durch das Inkludieren der entsprechenden Header-Datei (z.B. <code>&lt;string.h&gt;</code>).</p>
            </div>
            <div class="definition">
                <h4>Tokenizing</h4>
                <p>Der Prozess, eine Zeichenkette anhand eines oder mehrerer Trennzeichen (Delimiter) in eine Reihe von kleineren Teil-Zeichenketten (Tokens) zu zerlegen. Beispiel: Die Zeile "Max;Mustermann" wird mit dem Delimiter ";" in die Tokens "Max" und "Mustermann" zerlegt.</p>
            </div>
            <div class="definition">
                <h4>Pseudo-Zufallszahl</h4>
                <p>Eine Zahl, die von einem Algorithmus erzeugt wird und zuf√§llig erscheint, aber bei gleichem Startwert (Seed) immer dieselbe Sequenz erzeugt.</p>
            </div>
             <div class="definition">
                <h4>Seed (Startwert)</h4>
                <p>Ein Initialwert f√ºr einen Zufallszahlengenerator. Um bei jedem Programmstart eine andere Zufallssequenz zu erhalten, wird oft die aktuelle Uhrzeit als Seed verwendet.</p>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            
            <h3>1. <code>&lt;string.h&gt;</code> ‚Äì Der Werkzeugkasten f√ºr Zeichenketten</h3>
            <ul>
                <li><strong>L√§nge ermitteln:</strong> <code>size_t strlen(const char* str);</code> gibt die Anzahl der Zeichen <i>ohne</i> das `\0`-Zeichen zur√ºck.</li>
                <li><strong>Sicher kopieren:</strong> <code>errno_t strcpy_s(char* dest, rsize_t dest_size, const char* src);</code> kopiert einen String sicher in einen Puffer.</li>
                <li><strong>Vergleichen:</strong> <code>int strcmp(const char* str1, const char* str2);</code> vergleicht zwei Strings lexikographisch. Gibt `< 0` (str1<str2), `0` (str1==str2) oder `> 0` (str1>str2) zur√ºck.</li>
                <li><strong>Suchen:</strong> <code>char* strchr(const char* str, int character);</code> findet das erste Vorkommen eines Zeichens in einem String.</li>
                <li><strong>Zerlegen (Tokenizing):</strong> <code>char* strtok_s(char* str, const char* delimiters, char** context);</code> zerlegt einen String in Tokens.</li>
            </ul>

            <h3>2. <code>&lt;stdlib.h&gt;</code> ‚Äì Allgemeine Hilfsmittel</h3>
            <ul>
                <li><strong>String-Konvertierung:</strong> <code>int atoi(const char* str);</code> (ASCII to integer), <code>double atof(const char* str);</code> (ASCII to float). F√ºr eine robuste Konvertierung mit Fehlerpr√ºfung ist `strtod` vorzuziehen. </li>
                <li><strong>Zufallszahlen:</strong> <code>int rand(void);</code> gibt eine Zufallszahl zwischen 0 und `RAND_MAX` zur√ºck. Muss vorher mit <code>void srand(unsigned int seed);</code> initialisiert werden.</li>
                <li><strong>Dynamischer Speicher:</strong> <code>void* malloc(size_t size);</code> und <code>void free(void* ptr);</code> sind fundamental f√ºr Aufgaben mit dynamischen Datenstrukturen.</li>
            </ul>

            <h3>3. <code>&lt;math.h&gt;</code> ‚Äì F√ºr Mathematiker</h3>
            <ul>
                <li><strong>Potenz & Wurzel:</strong> <code>double pow(double base, double exponent);</code> (Potenz), <code>double sqrt(double x);</code> (Quadratwurzel).</li>
                <li><strong>Trigonometrie:</strong> <code>double sin(double x);</code>, <code>double cos(double x);</code>. F√ºr die Umrechnung von kartesischen in Polarkoordinaten ist <code>double atan2(double y, double x);</code> extrem n√ºtzlich, da sie den korrekten Quadranten ber√ºcksichtigt.</li>
            </ul>

            <h3>4. <code>&lt;time.h&gt;</code> ‚Äì Alles rund um die Zeit</h3>
            <ul>
                <li><strong>Seed f√ºr Zufallszahlen:</strong> <code>time_t time(time_t* timer);</code> wird oft mit `NULL` aufgerufen, um die Sekunden seit dem 1.1.1970 zu erhalten ‚Äì ein perfekter, sich st√§ndig √§ndernder Seed: `srand((unsigned int)time(NULL));`</li>
                <li><strong>Laufzeitmessung:</strong> <code>clock_t clock(void);</code> gibt die Anzahl der "CPU-Ticks" seit Programmstart zur√ºck. Die Differenz zweier `clock()`-Aufrufe geteilt durch `CLOCKS_PER_SEC` ergibt die vergangene Zeit in Sekunden.</li>
            </ul>
        </section>

        <section>
            <h2>5. Beispielprogramm 1: Zufalls-Passwort-Generator</h2>
            <p>Dieses Programm kombiniert <code>stdlib.h</code> und <code>time.h</code>, um ein zuf√§lliges Passwort zu erzeugen.</p>
            <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void) {
    char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
    char password[11]; // 10 Zeichen + Nullterminator
    int charset_length = sizeof(charset) - 1;

    // 1. Zufallsgenerator mit der aktuellen Zeit initialisieren
    srand((unsigned int)time(NULL));

    // 2. 10 zuf√§llige Zeichen ausw√§hlen
    for (int i = 0; i < 10; i++) {
        int random_index = rand() % charset_length;
        password[i] = charset[random_index];
    }
    // 3. String korrekt abschlie√üen
    password[10] = '\0';

    printf("Ihr zufaelliges Passwort: %s\n", password);

    return 0;
}
</code></pre>

            <h2>Beispielprogramm 2: Laufzeit einer Schleife messen</h2>
            <p>Dieses Programm nutzt `time.h`, um zu messen, wie lange eine rechenintensive Schleife zur Ausf√ºhrung ben√∂tigt. [vgl. 5618, 5620]</p>
            <pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

void long_running_task(void) {
    long long sum = 0;
    // Eine Schleife mit vielen Durchl√§ufen, um die Zeitmessung sichtbar zu machen
    for (int i = 0; i < 200000000; i++) {
        sum += i;
    }
}

int main(void) {
    clock_t start, end;
    double cpu_time_used;

    // 1. Startzeitpunkt merken
    start = clock();

    // 2. Die zu messende Funktion aufrufen
    long_running_task();

    // 3. Endzeitpunkt merken
    end = clock();

    // 4. Differenz berechnen und in Sekunden umrechnen
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    printf("Die Funktion benoetigte %f Sekunden CPU-Zeit.\n", cpu_time_used);

    return 0;
}
</code></pre>
        </section>

        <section>
            <h2>6. √úbungsaufgaben</h2>
            <ol>
                <li>
                    <strong>Text umkehren</strong><br>
                    Frage den Benutzer nach einem Wort. Lies es mit `scanf_s` ein. Benutze `strlen` um die L√§nge zu ermitteln und gib das Wort dann mit einer `for`-Schleife, die r√ºckw√§rts l√§uft, umgekehrt wieder auf der Konsole aus.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Wenn die L√§nge `L` ist, l√§uft die Schleife von `i = L - 1` abw√§rts bis `0` und gibt `wort[i]` aus.</p>
                    </details>
                </li>
                <li>
                    <strong>Gleich oder nicht?</strong><br>
                    Schreibe ein Programm, das den Benutzer nach seinem Passwort fragt. Vergleiche die Eingabe mit dem geheimen Passwort "topsecret" mittels `strcmp`. Gib aus, ob die Eingabe korrekt war oder nicht.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>`strcmp` gibt `0` zur√ºck, wenn die Strings identisch sind. Die Bedingung lautet also `if (strcmp(eingabe, "topsecret") == 0)`.</p>
                    </details>
                </li>
                 <li>
                    <strong>Abstand zweier Punkte</strong><br>
                    Definiere eine `struct Point {double x; double y;}`. Frage den Benutzer nach den Koordinaten von zwei Punkten. Berechne den Abstand zwischen ihnen mit der Formel $\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$. Verwende `sqrt` und `pow` aus `math.h`.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Die Implementierung ist eine direkte √úbersetzung der Formel: `distance = sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));`.</p>
                    </details>
                </li>
                 <li>
                    <strong>Robuster Zahlen-Input</strong><br>
                    Schreibe ein Programm, das eine Zeile Text einliest. Verwende `strtod`, um zu versuchen, eine `double`-Zahl vom Anfang der Zeile zu konvertieren. Gib eine Fehlermeldung aus, wenn die Konvertierung fehlschlug oder wenn nach der Zahl noch weitere Zeichen (au√üer Leerzeichen) folgten. [vgl. 5615]
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>`strtod` nimmt einen `char**` als zweiten Parameter. Nach dem Aufruf zeigt dieser Zeiger auf das erste Zeichen nach der konvertierten Zahl. Du kannst pr√ºfen, ob dieses Zeichen `\0` oder ein Leerzeichen ist.</p>
                    </details>
                </li>
                <li>
                    <strong>W√ºrfel-Simulator</strong><br>
                    Simuliere 100 W√ºrfe eines sechsseitigen W√ºrfels. Initialisiere den Zufallsgenerator mit `srand` und `time`. Generiere in einer Schleife 100 Zufallszahlen und bilde sie auf den Bereich 1-6 ab. Gib jeden Wurf aus.
                     <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Die Formel f√ºr einen W√ºrfelwurf ist `(rand() % 6) + 1`. Der Modulo-Operator `% 6` erzeugt Zahlen von 0-5, die Addition von 1 verschiebt den Bereich auf 1-6.</p>
                    </details>
                </li>
            </ol>
        </section>

        <section>
            <h2>7. Zusammenfassung & Spickzettel</h2>
            <pre><code>// --- string.h ---
#include &lt;string.h&gt;
strlen(str);          // L√§nge
strcmp(s1, s2);       // Vergleichen
strcpy_s(d, sz, s);   // Kopieren
strcat_s(d, sz, s);   // Anh√§ngen
strtok_s(s, d, &ctx); // Zerlegen

// --- stdlib.h ---
#include &lt;stdlib.h&gt;
atoi(str);  // String zu int
atof(str);  // String zu double
srand(seed); // Zufallsgenerator initialisieren
rand();     // N√§chste Zufallszahl holen
qsort(...); // Sortieren

// --- math.h ---
#define _USE_MATH_DEFINES // F√ºr M_PI in MSVS
#include &lt;math.h&gt;
pow(base, exp); // Potenz
sqrt(val);      // Quadratwurzel
sin(rad), cos(rad);
atan2(y, x);    // Sicherer Arkustangens
ceil(val), floor(val); // Auf-/Abrunden

// --- time.h ---
#include &lt;time.h&gt;
// Seed f√ºr srand
srand((unsigned int)time(NULL));
// Laufzeitmessung
clock_t start = clock();
// ... code ...
clock_t end = clock();
double duration = ((double)(end-start))/CLOCKS_PER_SEC;
</code></pre>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/c/KE11_IngInf_Standardbibliothek_V3.0.1.pdf" download>Folien herunterladen (PDF)</a></p>
            <p><a href="../material/c/Uebungen_Ing.-Inf._KE11_V3.0.2.pdf" download>√úbungsblatt herunterladen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="10_Modulare_Programmierung_Kommandozeile.html">&larr; Vorheriges Kapitel</a>
  <a href="12_Threads.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
        <p>&copy; 2025 - Dein pers√∂nlicher Programmier-Tutor</p>
    </footer>

<script src="../toggleTheme.js"></script>
</body>
</html>