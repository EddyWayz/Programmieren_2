<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 7: Zeiger (Teil 2)</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="index.html">C</a>
    <a href="../cpp/index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 7: Zeiger (Teil 2) - Zeigerarithmetik & Dynamischer Speicher</h1>
        <p>Den Speicher navigieren und zur Laufzeit verwalten.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Nach dieser Einheit kannst du mittels <strong>Zeigerarithmetik</strong> effizient durch Arrays navigieren. Du verstehst die √Ñquivalenz von Array- und Zeigernotation. Das Kernlernziel ist die Beherrschung der <strong>dynamischen Speicherverwaltung</strong>: Du wei√üt, was der <strong>Heap</strong> ist und kannst mit <code>malloc()</code> Speicher zur Laufzeit anfordern, ihn nutzen und mit <code>free()</code> wieder korrekt freigeben. Du bist dir der Gefahr von <strong>Speicherlecks (Memory Leaks)</strong> bewusst und kennst den sicheren Workflow, um diese zu vermeiden.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Wenn einfache Zeiger das "Sehen" von Speicheradressen erm√∂glichen, dann ist Zeigerarithmetik das "Gehen" ‚Äì die F√§higkeit, sich gezielt im Speicher zu bewegen. Dieses Konzept ist fundamental, um zu verstehen, wie Arrays intern funktionieren.
            </p>
            <p>
                Die gr√∂√üte Einschr√§nkung, die wir bisher hatten, war, dass die Gr√∂√üe all unserer Daten (insbesondere Arrays) zur Kompilierzeit feststehen musste. Was aber, wenn wir ein Programm schreiben, das eine vom Benutzer angegebene Anzahl von Werten verarbeiten soll? Hier kommt die dynamische Speicherverwaltung ins Spiel. Sie erlaubt es einem Programm, flexibel auf Anforderungen zu reagieren und Speicher genau dann anzufordern, wenn er gebraucht wird. Dies ist die Grundlage f√ºr alle flexiblen Datenstrukturen und ein Kennzeichen professioneller Software.
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>Zeigerarithmetik</h4>
                <p>Die Durchf√ºhrung von arithmetischen Operationen (wie Addition oder Inkrement) auf Zeigern. Eine Operation wie <code>pointer++</code> erh√∂ht die Adresse nicht um 1, sondern um die Gr√∂√üe des Datentyps, auf den der Zeiger zeigt (z.B. um 4 Bytes bei einem <code>int*</code>). </p>
            </div>
            <div class="definition">
                <h4>Heap</h4>
                <p>Ein gro√üer, flexibler Speicherbereich, aus dem ein Programm zur Laufzeit Speicherbl√∂cke anfordern kann. Im Gegensatz zum Stack, der automatisch verwaltet wird, ist der Programmierer f√ºr die Freigabe von Heap-Speicher selbst verantwortlich.</p>
            </div>
            <div class="definition">
                <h4>Dynamische Speicherverwaltung</h4>
                <p>Der Prozess, Speicher auf dem Heap zur Laufzeit anzufordern (Allokation) und wieder freizugeben (Deallokation). </p>
            </div>
            <div class="definition">
                <h4>`malloc()`</h4>
                <p>Die Standard-Bibliotheksfunktion (`memory allocation`) zum Anfordern eines Speicherblocks einer bestimmten Gr√∂√üe vom Heap. Sie gibt einen `void*`-Zeiger auf den Anfang des Blocks oder `NULL` im Fehlerfall zur√ºck. </p>
            </div>
            <div class="definition">
                <h4>`free()`</h4>
                <p>Die Standard-Bibliotheksfunktion zum Freigeben eines zuvor mit `malloc`, `calloc` oder `realloc` allokierten Speicherblocks. </p>
            </div>
             <div class="definition">
                <h4>Speicherleck (Memory Leak)</h4>
                <p>Ein Programmierfehler, bei dem dynamisch allokierter Speicher nicht mehr freigegeben wird. Das Programm verliert die Referenz (den Zeiger) auf den Speicher, kann ihn aber nicht mehr nutzen, was auf Dauer den verf√ºgbaren Speicher des Systems aufbraucht. </p>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            
            <h3>1. Navigieren mit Zeigerarithmetik</h3>
            <p>Ein Array-Name ist im Grunde ein konstanter Zeiger auf das erste Element. Daher k√∂nnen wir mit Zeigerarithmetik auf alle Elemente zugreifen. Die beiden folgenden Schreibweisen sind √§quivalent: </p>
            <pre><code>int numbers[] = {10, 20, 30, 40};
int* p = numbers; // p zeigt jetzt auf numbers[0]

// Zugriff auf das dritte Element (Index 2)
int val1 = numbers[2];      // Klassische Array-Notation
int val2 = *(p + 2);        // √Ñquivalente Zeiger-Notation
// Lese: "Gehe von p aus 2 Elemente weiter und dereferenziere dann."

printf("Wert 1: %d, Wert 2: %d\n", val1, val2); // Beide sind 30
</code></pre>
            
            <h3>2. Der Lebenszyklus der dynamischen Speicherverwaltung</h3>
            <p>Die Arbeit mit dynamischem Speicher folgt immer einem strengen, sicheren Muster in <strong>sechs Schritten</strong>:</p>
            <pre><code>#include &lt;stdlib.h&gt; // F√ºr malloc() und free()

void dynamic_demo(int size) {
    // SCHRITT 1: Zeiger deklarieren und mit NULL initialisieren.
    int* p_dynamic_array = NULL;

    // SCHRITT 2: Speicher anfordern.
    // Der Cast (int*) ist f√ºr C++ Kompatibilit√§t gute Praxis.
    p_dynamic_array = (int*)malloc(size * sizeof(int));

    // SCHRITT 3: √úberpr√ºfen, ob die Anforderung erfolgreich war! KRITISCH!
    if (p_dynamic_array == NULL) {
        printf("Fehler: Speicher konnte nicht allokiert werden!\n");
        return; // Funktion sicher beenden
    }

    // SCHRITT 4: Den Speicher nutzen (wie ein normales Array).
    printf("Speicher erfolgreich allokiert. F√ºlle ihn...\n");
    for (int i = 0; i < size; i++) {
        p_dynamic_array[i] = i * i;
    }

    // SCHRITT 5: Den Speicher wieder freigeben, wenn er nicht mehr gebraucht wird.
    free(p_dynamic_array);

    // SCHRITT 6: Den Zeiger auf NULL setzen, um "dangling pointers" zu vermeiden.
    p_dynamic_array = NULL;
}
</code></pre>

        </section>

        <section>
            <h2>5. Beispielprogramm 1: Array-Summe mit Zeigerarithmetik</h2>
            <p>Dieses Programm berechnet die Summe aller Elemente eines Arrays, greift dabei aber ausschlie√ülich √ºber Zeigernotation auf die Elemente zu.</p>
            <pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int values[] = {5, 10, 15, 20, 25};
    int* p_val = values; // Zeiger auf das erste Element
    int sum = 0;
    
    // sizeof(values) ist die Gr√∂√üe des gesamten Arrays in Bytes.
    // sizeof(int) ist die Gr√∂√üe eines einzelnen Elements.
    // Die Division ergibt die Anzahl der Elemente.
    int num_elements = sizeof(values) / sizeof(int);

    printf("Berechne die Summe der Elemente...\n");
    for (int i = 0; i < num_elements; i++) {
        // Lese den Wert an der Adresse (p_val + i) und addiere ihn zur Summe.
        sum += *(p_val + i);
    }
    
    printf("Die Summe ist: %d\n", sum);
    
    return 0;
}
</code></pre>

            <h2>Beispielprogramm 2: Flexibles Array zur Laufzeit</h2>
            <p>Dieses Programm ist das Paradebeispiel f√ºr dynamischen Speicher. Es fragt den Benutzer, wie viele Zahlen er speichern m√∂chte, allokiert genau so viel Speicher, f√ºllt ihn und gibt ihn am Ende wieder frei. [vgl. 5175]</p>
            <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    int count = 0;
    short* p_numbers = NULL; // Schritt 1

    printf("Wie viele Zahlen moechten Sie speichern? ");
    scanf_s("%d", &count);

    // Schritt 2: Speicher anfordern
    p_numbers = (short*)malloc(count * sizeof(short));

    // Schritt 3: Erfolg pr√ºfen
    if (p_numbers == NULL) {
        printf("Fehler bei der Speicheranforderung!\n");
        return 1; // Programm mit Fehlercode beenden
    }

    // Schritt 4: Speicher nutzen
    for (int i = 0; i < count; i++) {
        p_numbers[i] = (short)(i + 1); // F√ºllen mit 1, 2, 3, ...
    }
    printf("Die %d Zahlen sind:\n", count);
    for (int i = 0; i < count; i++) {
        printf("%d ", p_numbers[i]);
    }
    printf("\n");

    // Schritt 5: Speicher freigeben
    free(p_numbers);

    // Schritt 6: Zeiger auf NULL setzen
    p_numbers = NULL;
    
    printf("Speicher wurde erfolgreich freigegeben.\n");
    return 0;
}
</code></pre>
        </section>

        <section>
            <h2>6. √úbungsaufgaben</h2>
            <ol>
                <li>
                    <strong>Zeigerarithmetik anwenden</strong><br>
                    Definiere ein `int`-Array mit 5 Elementen und initialisiere es. Definiere einen `int`-Zeiger, der auf das <strong>dritte</strong> Element (Index 2) zeigt. Gib den Wert aus, auf den er zeigt. Dekrementiere den Zeiger danach einmal und gib den neuen Wert aus. [vgl. 5135, 5137, 5146, 5147]
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Initialisierung: `int* p = &my_array[2];`. Ausgabe: `*p`. Dekrement: `p--;`. Neue Ausgabe: `*p`.</p>
                    </details>
                </li>
                <li>
                    <strong>Array durchlaufen (nur mit Zeiger)</strong><br>
                    Definiere ein `char`-Array mit dem Inhalt "Hallo". Erstelle einen `char`-Zeiger, der auf den Anfang des Arrays zeigt. Schreibe eine `while`-Schleife, die so lange l√§uft, bis der Zeiger auf das Nullzeichen `\0` zeigt. In der Schleife gib das Zeichen aus, auf das der Zeiger zeigt, und inkrementiere dann den Zeiger.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Die Schleifenbedingung lautet `while (*p != '\0')`. Innerhalb der Schleife: `printf("%c", *p); p++;`.</p>
                    </details>
                </li>
                 <li>
                    <strong>Dynamische Kopie eines Strings</strong><br>
                    Schreibe ein Programm, das den Benutzer nach seinem Vornamen fragt. Allokiere danach mit `malloc` exakt so viel Speicher, wie f√ºr den Namen (inklusive `\0`) ben√∂tigt wird. Kopiere den Namen in den neuen Speicher und gib die Kopie aus. Gib den Speicher am Ende frei.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Lies den Namen zuerst in einen gro√üen, statischen Puffer ein (z.B. `char buffer[100];`). Benutze `strlen(buffer)` um die L√§nge zu ermitteln. Allokiere `strlen(buffer) + 1` Bytes. Kopiere mit `strcpy_s` und gib am Ende den Speicher mit `free` frei.</p>
                    </details>
                </li>
                 <li>
                    <strong>`calloc` f√ºr sauberen Speicher</strong><br>
                    Allokiere dynamisch ein Array f√ºr 10 `double`-Werte einmal mit `malloc` und einmal mit `calloc`. Schreibe f√ºr jeden Fall eine Schleife, die die 10 Werte direkt nach der Allokation ausgibt. Welchen Unterschied stellst du fest?
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Der Speicher von `malloc` wird zuf√§llige "M√ºll"-Werte enthalten. Der Speicher von `calloc` wird sauber mit `0.0` initialisiert sein. </p>
                    </details>
                </li>
                <li>
                    <strong>Speicherleck provozieren</strong><br>
                    Schreibe eine Funktion `void memory_leak_creator(void)`. Innerhalb dieser Funktion allokierst du Speicher f√ºr 1000 `int`s und tust sonst nichts. Rufe diese Funktion in `main` auf. Beschreibe in einem Kommentar, warum hier ein Speicherleck entsteht.
                     <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Der Zeiger, der die Adresse des allokierten Speichers h√§lt, ist eine lokale Variable der Funktion. Sobald die Funktion endet, ist dieser Zeiger weg. Der Speicher auf dem Heap bleibt aber reserviert und ist nun f√ºr immer verloren, da es keine Referenz mehr auf ihn gibt.</p>
                    </details>
                </li>
            </ol>
        </section>

        <section>
            <h2>7. Zusammenfassung & Spickzettel</h2>
            <pre><code>// --- ZEIGERARITHMETIK ---
int arr[5];
int* p = arr; // p zeigt auf arr[0]

// Zugriff auf das i-te Element:
arr[i]    // Array-Notation
*(p + i)  // Zeiger-Notation (√Ñquivalent)

// Zeiger inkrementieren:
p++; // p zeigt jetzt auf arr[1]

// --- DYNAMISCHER SPEICHER: DER SICHERE WORKFLOW ---
#include &lt;stdlib.h&gt;

// 1. Deklarieren & Initialisieren
Datentyp* p_mem = NULL;

// 2. Anfordern & Casten
p_mem = (Datentyp*)malloc(ANZAHL * sizeof(Datentyp));

// 3. Auf NULL pr√ºfen!
if (p_mem == NULL) {
    // Fehlerbehandlung!
}

// 4. Speicher nutzen (z.B. p_mem[i] = ...)

// 5. Freigeben
free(p_mem);

// 6. Zeiger auf NULL setzen
p_mem = NULL;
</code></pre>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/c/KE07_IngInf_Zeiger2_V3.0.1.pdf" download>Folien herunterladen (PDF)</a></p>
            <p><a href="../material/c/Uebungen_Ing.-Inf._KE07_V3.0.2.pdf" download>√úbungsblatt herunterladen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="06_Zeiger_Grundlagen.html">&larr; Vorheriges Kapitel</a>
  <a href="08_Zeiger_Fortgeschritten.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
        <p>&copy; 2025 - Dein pers√∂nlicher Programmier-Tutor</p>
    </footer>

<script src="../toggleTheme.js"></script>
</body>
</html>