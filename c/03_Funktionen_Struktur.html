<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 3: Funktionen</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="index.html">C</a>
    <a href="../cpp/index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 3: Funktionen: Struktur, G√ºltigkeit & Wiederverwendung</h1>
        <p>Code in logische, wiederverwendbare Bl√∂cke gliedern.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Nach dieser Einheit bist du in der Lage, C-Code mithilfe von Funktionen logisch zu strukturieren. Du verstehst den Unterschied zwischen <strong>Deklaration, Definition und Aufruf</strong> einer Funktion und kannst dieses Wissen anwenden.  Du kannst Daten mittels Parametern an Funktionen √ºbergeben und Ergebnisse per R√ºckgabewert erhalten. Du kannst den <strong>G√ºltigkeitsbereich (Scope)</strong> von Variablen (lokal vs. global) erkl√§ren und die Speicherklassen <code>auto</code> und <code>static</code> gezielt einsetzen.  Schlie√ülich wei√üt du, wie man Funktionen aus Standardbibliotheken wie <code>math.h</code> einbindet und nutzt.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Stell dir vor, du baust ein Auto. Du gie√üt nicht das gesamte Fahrzeug aus einem einzigen St√ºck Metall. Stattdessen fertigst du einzelne, getestete Komponenten ‚Äì Motor, R√§der, Karosserie ‚Äì und f√ºgst sie zusammen.  In der Programmierung sind Funktionen genau das: kleine, spezialisierte und wiederverwendbare Bauteile. 
            </p>
            <p>
                Dieses Prinzip nennt sich <strong>"Don't Repeat Yourself" (DRY)</strong>.  Anstatt denselben Code-Abschnitt immer wieder zu kopieren (und damit auch Fehler mitzukopieren), lagerst du ihn einmal in eine Funktion aus.  Diese Funktion kann dann beliebig oft aufgerufen werden.  Das macht deinen Code nicht nur k√ºrzer und √ºbersichtlicher, sondern auch einfacher zu warten: Eine √Ñnderung oder Fehlerbehebung muss nur an einer einzigen Stelle erfolgen. 
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>Funktion</h4>
                <p>Ein eigenst√§ndiger, benannter Code-Block, der eine spezifische Aufgabe erf√ºllt. Man kann sie sich als "Black-Box" vorstellen: Sie erh√§lt eine Eingabe (Input), verarbeitet sie und liefert eine Ausgabe (Output). </p>
            </div>
            <div class="definition">
                <h4>Deklaration (Prototyp)</h4>
                <p>Stellt eine Funktion dem Compiler vor, bevor sie verwendet wird.  Sie legt den Namen, den R√ºckgabetyp und die Typen der Parameter fest. Die Deklaration endet mit einem Semikolon. Beispiel: <code>double CalcArea(double r);</code></p>
            </div>
            <div class="definition">
                <h4>Definition</h4>
                <p>Die vollst√§ndige Implementierung einer Funktion. Sie enth√§lt den Code, der ausgef√ºhrt wird, wenn die Funktion aufgerufen wird.  Hier werden auch die Anweisungen im Funktionsk√∂rper platziert.</p>
            </div>
            <div class="definition">
                <h4>Parameter & Argument</h4>
                <p><strong>Parameter</strong> sind die Variablen in der Funktionsdeklaration/-definition (z.B. <code>double r</code>).  <strong>Argumente</strong> sind die tats√§chlichen Werte, die beim Aufruf an die Funktion √ºbergeben werden (z.B. <code>CalcArea(10.5);</code>).</p>
            </div>
            <div class="definition">
                <h4>G√ºltigkeitsbereich (Scope)</h4>
                <p>Der Bereich im Code, in dem eine Variable sichtbar und nutzbar ist.  Man unterscheidet haupts√§chlich:</p>
                <ul>
                    <li><strong>Lokaler Scope</strong>: Die Variable ist nur innerhalb des Code-Blocks <code>{...}</code> g√ºltig, in dem sie definiert wurde. </li>
                    <li><strong>Globaler Scope</strong>: Die Variable wurde au√üerhalb aller Funktionen definiert und ist im gesamten Programm zug√§nglich.  (Sollte vermieden werden!)</li>
                </ul>
            </div>
             <div class="definition">
                <h4>Speicherklasse</h4>
                <p>Gibt Auskunft √ºber die Lebensdauer und Sichtbarkeit einer Variable.  Die wichtigsten sind:</p>
                 <ul>
                    <li><strong><code>auto</code></strong>: Die Standard-Speicherklasse f√ºr lokale Variablen.  Sie wird bei jedem Eintritt in ihren Block neu erstellt (mit zuf√§lligem Wert) und am Ende zerst√∂rt. </li>
                    <li><strong><code>static</code></strong>: Eine lokale `static`-Variable wird nur einmal initialisiert (mit 0) und beh√§lt ihren Wert zwischen den Funktionsaufrufen. </li>
                </ul>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            
            <h3>Der Lebenszyklus einer Funktion: Deklarieren, Definieren, Aufrufen</h3>
            <p>F√ºr eine saubere Programmstruktur folgt man einem klaren Muster:</p>
            <pre><code>#include &lt;stdio.h&gt;

// 1. DEKLARATION (Prototyp)
// Sagt dem Compiler: "Es gibt eine Funktion namens AddValues, sie erwartet zwei int und gibt ein int zur√ºck."
int AddValues(int iA, int iB);

// Die main-Funktion kann AddValues jetzt schon aufrufen.
int main(void) {
    int val1 = 10;
    int summe;

    // 3. AUFRUF
    // Die Argumente 5 und 13 werden in die Parameter iA und iB kopiert.
    summe = AddValues(5, 13);
    
    printf("Die Summe ist: %d\n", summe);
    return 0;
}

// 2. DEFINITION (Implementierung)
// Hier steht, was die Funktion tats√§chlich tut.
int AddValues(int iA, int iB) {
    int iResult = iA + iB;
    return iResult; // Gibt das Ergebnis an den Aufrufer (main) zur√ºck.
}
</code></pre>

            <h3>Die vier Grundformen von Funktionen</h3>
            <p>Funktionen k√∂nnen in vier Kombinationen von Parametern und R√ºckgabewerten auftreten: </p>
            <ol>
                <li><strong>Ohne Parameter, ohne R√ºckgabewert</strong>: F√ºhrt eine feste Aktion aus. <code>void PrintGreeting(void);</code> </li>
                <li><strong>Mit Parametern, ohne R√ºckgabewert</strong>: Bekommt Daten, f√ºhrt damit eine Aktion aus. <code>void PrintNumber(int num);</code> </li>
                <li><strong>Ohne Parameter, mit R√ºckgabewert</strong>: Liefert einen Wert aus einer internen Quelle. <code>int GetRandomNumber(void);</code> </li>
                <li><strong>Mit Parametern, mit R√ºckgabewert</strong>: Der h√§ufigste Fall. Verarbeitet Eingaben zu einer Ausgabe. <code>int AddValues(int a, int b);</code> </li>
            </ol>
            
            <h3>Scope: Wer sieht was?</h3>
            <p>Eine lokale Variable "√ºberschattet" immer eine globale Variable mit demselben Namen.</p>
            <pre><code>#include &lt;stdio.h&gt;

int iVar = 42; // Globale Variable

void TestScope(void) {
    int iVar = 72; // Lokale Variable mit gleichem Namen
    printf("In TestScope: iVar ist %d\n", iVar); // Greift auf die LOKALE Variable zu!
}

int main(void) {
    printf("In main (vorher): iVar ist %d\n", iVar); // Greift auf die GLOBALE Variable zu
    TestScope();
    printf("In main (nachher): iVar ist %d\n", iVar); // Greift immer noch auf die GLOBALE zu
    return 0;
}
// Ausgabe: 42, 72, 42
</code></pre>
            <p class="warning">Regel: Bei Namenskonflikten wird immer die Variable mit dem "n√§heren" G√ºltigkeitsbereich verwendet. </p>
            
            <h3><code>static</code> vs. <code>auto</code>: Das Ged√§chtnis einer Funktion</h3>
            <p>Der Unterschied wird bei wiederholten Aufrufen deutlich:</p>
            <pre><code>void Counter() {
    auto int normalCounter = 0;
    static int staticCounter = 0; // Wird nur beim allerersten Aufruf initialisiert!
    
    normalCounter++;
    staticCounter++;
    
    printf("Auto: %d, Static: %d\n", normalCounter, staticCounter);
}

int main(void) {
    Counter(); // Ausgabe: Auto: 1, Static: 1
    Counter(); // Ausgabe: Auto: 1, Static: 2
    Counter(); // Ausgabe: Auto: 1, Static: 3
    return 0;
}
</code></pre>
            <p>Die <code>auto</code>-Variable wird bei jedem Aufruf auf 0 zur√ºckgesetzt, w√§hrend die <code>static</code>-Variable ihren Wert beh√§lt. </p>
        </section>

        <section>
            <h2>5. Beispielprogramme</h2>

            <h3>Beispiel 1: Geometrie-Rechner mit Funktionen</h3>
            <p>Dieses Programm l√∂st Aufgabe 1 des √úbungsblatts, indem es die Berechnungen f√ºr Kugelvolumen und Kreisfl√§che in eigene Funktionen auslagert. </p>
            <pre><code>#include &lt;stdio.h&gt;

// Globale Konstante f√ºr PI [vgl. 1470]
const double PI = 3.1415926535;

// --- Deklarationen ---
double CalcVolumeSphere(double radius);
double CalcAreaCircle(double radius);

int main(void) {
    double r = 10.0; // Lokale Variable f√ºr den Radius [vgl. 1471]

    // Funktionen aufrufen und Ergebnisse in lokalen Variablen speichern [vgl. 1472]
    double volume = CalcVolumeSphere(r);
    double area = CalcAreaCircle(r);

    // Ergebnisse ausgeben [vgl. 1473]
    printf("Radius: %.2f\n", r);
    printf("Kugelvolumen: %.4f\n", volume);
    printf("Kreisflaeche: %.4f\n", area);
    
    return 0;
}

// --- Definitionen ---
// Berechnet das Volumen einer Kugel [vgl. 1475]
double CalcVolumeSphere(double radius) {
    return (4.0 / 3.0) * PI * radius * radius * radius;
}

// Berechnet die Fl√§che eines Kreises [vgl. 1475]
double CalcAreaCircle(double radius) {
    return PI * radius * radius;
}
</code></pre>

            <h3>Beispiel 2: Quadratwurzel mit der Mathe-Bibliothek</h3>
            <p>Dieses Programm l√∂st Aufgabe 4 des √úbungsblatts.  Es zeigt, wie man recherchiert, welche Funktion man braucht (<code>sqrt</code>), die passende Bibliothek einbindet (<code>math.h</code>) und mit m√∂glichen Fehlern umgeht. </p>
            <pre><code>// math.h f√ºr die sqrt-Funktion einbinden
#include &lt;math.h&gt; 
#include &lt;stdio.h&gt;

int main(void) {
    double value;
    
    printf("Geben Sie eine Zahl ein, um die Wurzel zu ziehen: ");
    scanf("%lf", &value);

    // Pr√ºfung, ob die Eingabe g√ºltig ist [vgl. 1522]
    if (value < 0) {
        printf("Fehler: Die Wurzel aus einer negativen Zahl ist nicht definiert.\n");
    } else {
        double result = sqrt(value);
        printf("Die Wurzel aus %.4f ist %.4f.\n", value, result);
    }
    
    // Test mit negativem Wert, der zu 'nan' (Not a Number) f√ºhrt [vgl. 1523]
    printf("\nTest: sqrt(-9.0) ergibt: %f\n", sqrt(-9.0));

    return 0;
}
</code></pre>
        </section>

        <section>
            <h2>6. √úbungsaufgaben</h2>
            <ol>
                <li>
                    <strong>Einfacher Gru√ü</strong><br>
                    Schreibe eine Funktion <code>void PrintGreeting(void)</code>, die einfach "Hallo aus meiner ersten Funktion!" auf der Konsole ausgibt. Deklariere sie √ºber <code>main</code>, definiere sie darunter und rufe sie in <code>main</code> auf.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Die Funktion hat leere Klammern <code>(void)</code> und den R√ºckgabetyp <code>void</code>. Ihr einziger Inhalt ist ein <code>printf</code>-Aufruf.</p>
                    </details>
                </li>
                <li>
                    <strong>Rechteck-Rechner</strong><br>
                    Implementiere eine Funktion <code>double CalcRectangleArea(double width, double height)</code>, die die Fl√§che eines Rechtecks berechnet und zur√ºckgibt. Frage in <code>main</code> den Benutzer nach Breite und H√∂he, rufe die Funktion auf und gib das Ergebnis aus.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Die Funktion ben√∂tigt zwei <code>double</code>-Parameter. Die Definition ist kurz: <code>return width * height;</code>. In <code>main</code> brauchst du <code>scanf</code> und <code>printf</code>.</p>
                    </details>
                </li>
                 <li>
                    <strong>Scope-Detektiv</strong><br>
                    Schreibe ein Programm wie in Aufgabe 2 des √úbungsblatts: Definiere eine globale Variable <code>int myVar = 100;</code>. Definiere in `main` eine lokale Variable <code>int myVar = 200;</code>. Gib den Wert von `myVar` in `main` aus. Was wird angezeigt und warum?
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Es wird `200` ausgegeben. Die lokale Variable in `main` "√ºberschattet" die globale Variable. Der Compiler w√§hlt immer den n√§chstgelegenen, g√ºltigen Scope. </p>
                    </details>
                </li>
                 <li>
                    <strong>Statischer Z√§hler</strong><br>
                    Schreibe eine Funktion <code>void CountMyCalls(void)</code>, die eine lokale <code>static int</code>-Variable enth√§lt. Bei jedem Aufruf soll die Variable um 1 erh√∂ht und ihr neuer Wert ausgegeben werden. Rufe die Funktion in <code>main</code> drei Mal hintereinander auf.
                    <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Code innerhalb der Funktion: <code>static int counter = 0; counter++; printf("Aufruf Nummer: %d\n", counter);</code>. Die Ausgabe sollte "Aufruf Nummer: 1", "... 2", "... 3" sein.</p>
                    </details>
                </li>
                <li>
                    <strong>Finde das Maximum</strong><br>
                    Implementiere eine Funktion <code>int GetMax(int a, int b)</code>. Sie soll den gr√∂√üeren der beiden √ºbergebenen Integer-Werte zur√ºckgeben. Teste die Funktion in <code>main</code> mit verschiedenen Werten.
                     <details>
                        <summary>Hinweis / L√∂sungsskizze</summary>
                        <p>Innerhalb der Funktion kannst du eine einfache if-else-Struktur verwenden: <code>if (a > b) { return a; } else { return b; }</code>.</p>
                    </details>
                </li>
            </ol>
        </section>

        <section>
            <h2>7. Zusammenfassung & Spickzettel</h2>
            <pre><code>// --- SYNTAX & MUSTER ---
// Deklaration (Prototyp) - kommt vor die erste Verwendung
R√ºckgabetyp Funktionsname(Typ1 Param1, Typ2 Param2);

// Aufruf - passiert meist in main() oder anderen Funktionen
ergebnis_variable = Funktionsname(Argument1, Argument2);

// Definition - die eigentliche Logik
R√ºckgabetyp Funktionsname(Typ1 Param1, Typ2 Param2) {
    // ... Anweisungen ...
    return wert; // 'wert' muss vom Typ 'R√ºckgabetyp' sein
}

// --- VOID ---
// Kein R√ºckgabewert
void DoSomething(int param);
// Keine Parameter
int GetSomething(void);
// Weder noch
void DoSomethingSimple(void);

// --- G√úLTIGKEIT (SCOPE) ---
int g_myGlobal; // Global: √úberall sichtbar, vermeiden!

void func() {
    int myLocal; // Lokal: Nur in func() sichtbar
}

// --- SPEICHERKLASSEN (LOKAL) ---
void anotherFunc() {
    auto int temp = 0; // Standard. Wird bei jedem Aufruf neu erstellt.
    static int persistent = 0; // Beh√§lt Wert zwischen Aufrufen.
}

// --- STANDARD-BIBLIOTHEK EINBINDEN ---
#include &lt;math.h&gt; // F√ºr sqrt(), pow(), sin(), etc.
</code></pre>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/c/KE03_IngInf_Funktionen_V3.0.1.pdf" download>Folien herunterladen (PDF)</a></p>
            <p><a href="../material/c/Uebungen_Ing.-Inf._KE03_V3.0.2.pdf" download>√úbungsblatt herunterladen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="02_Operatoren_und_formatierte_IO.html">&larr; Vorheriges Kapitel</a>
  <a href="04_Kontrollstrukturen_Logik.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
        <p>&copy; 2025 - Dein pers√∂nlicher Programmier-Tutor</p>
    </footer>

<script src="../toggleTheme.js"></script>
</body>
</html>