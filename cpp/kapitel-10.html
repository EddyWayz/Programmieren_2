<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 10: N√ºtzliche Werkzeuge (Utilities)</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="../c/index.html">C</a>
    <a href="index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 10: N√ºtzliche Werkzeuge (Utilities)</h1>
        <p>Schreiben Sie sicheren, modernen und ausdrucksstarken C++-Code mit Smart Pointern und Lambda-Ausdr√ºcken.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Nach dieser Einheit k√∂nnen Sie die grundlegenden Probleme der manuellen Speicherverwaltung mit <code>new</code> und <code>delete</code> l√∂sen, indem Sie <strong>Smart Pointer</strong> (insbesondere <code>std::unique_ptr</code> und <code>std::shared_ptr</code>) verwenden. Sie verstehen das Konzept der ‚ÄûResource Acquisition Is Initialization‚Äú (RAII) und die Semantiken von alleinigem Besitz (unique ownership) und geteiltem Besitz (shared ownership). Des Weiteren k√∂nnen Sie anonyme Funktionen, sogenannte <strong>Lambda-Ausdr√ºcke</strong>, definieren und verwenden, um kurzen, pr√§gnanten Code direkt dort zu schreiben, wo er ben√∂tigt wird, insbesondere in Verbindung mit STL-Algorithmen.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Die manuelle Speicherverwaltung mit <code>new</code> und <code>delete</code> ist eine der gr√∂√üten Fehlerquellen in C++. Vergisst man ein <code>delete</code>, hat man ein Speicherleck. Ruft man <code>delete</code> zu fr√ºh oder doppelt auf, f√ºhrt das zu Abst√ºrzen. <strong>Smart Pointer</strong> l√∂sen dieses Problem, indem sie den Lebenszyklus eines dynamisch allokierten Objekts an ihre eigene Lebensdauer binden. Sobald der Smart Pointer selbst zerst√∂rt wird (z.B. am Ende eines G√ºltigkeitsbereichs), ruft er automatisch <code>delete</code> f√ºr das verwaltete Objekt auf. Das ist sicherer, einfacher und weniger fehleranf√§llig.
            </p>
            <p>
                <strong>Lambda-Ausdr√ºcke</strong> sind eine Revolution f√ºr die Arbeit mit STL-Algorithmen. Anstatt eine separate Funktion oder ein komplexes Funktionsobjekt definieren zu m√ºssen, nur um es einmalig an <code>std::sort</code> oder <code>std::find_if</code> zu √ºbergeben, k√∂nnen Sie die Logik direkt und anonym "inline" schreiben. Das macht den Code k√ºrzer, besser lesbar und h√§lt die Logik dort, wo sie hingeh√∂rt.
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>RAII (Resource Acquisition Is Initialization)</h4>
                <p>Ein zentrales Programmier-Idiom in C++. Es besagt, dass die Belegung einer Ressource (Speicher, Datei, Netzwerkverbindung) an die Lebenszeit eines Objekts gebunden wird. Der Konstruktor belegt die Ressource, der Destruktor gibt sie garantiert wieder frei. Smart Pointer sind die perfekte Umsetzung dieses Prinzips.</p>
            </div>
            <div class="definition">
                <h4>Smart Pointer</h4>
                <p>Ein Klassen-Template, das einen rohen Zeiger (raw pointer) umschlie√üt und dessen Lebenszyklus automatisch verwaltet. Er verh√§lt sich syntaktisch wie ein normaler Zeiger (mit <code>*</code> und <code>-></code>), verhindert aber Speicherlecks.</p>
            </div>
             <div class="definition">
                <h4><code>std::unique_ptr</code></h4>
                <p>Ein Smart Pointer, der den <strong>alleinigen Besitz</strong> an einem Objekt repr√§sentiert. Er kann nicht kopiert, aber verschoben (moved) werden. Wenn der <code>unique_ptr</code> zerst√∂rt wird, wird das Objekt gel√∂scht. Ideal f√ºr den Fall, dass eine Ressource genau einen Besitzer hat.</p>
            </div>
            <div class="definition">
                <h4><code>std::shared_ptr</code></h4>
                <p>Ein Smart Pointer, der <strong>geteilten Besitz</strong> erm√∂glicht. Er verwendet einen Referenzz√§hler: Mehrere <code>shared_ptr</code> k√∂nnen auf dasselbe Objekt zeigen. Das Objekt wird erst dann gel√∂scht, wenn der letzte <code>shared_ptr</code>, der darauf zeigt, zerst√∂rt wird.</p>
            </div>
            <div class="definition">
                <h4>Lambda-Ausdruck</h4>
                <p>Eine anonyme, lokale Funktion. Sie kann direkt an Ort und Stelle definiert werden. Ihre Syntax besteht aus einer Capture-Klausel <code>[]</code>, einer optionalen Parameterliste <code>()</code> und einem Funktionsk√∂rper <code>{}</code>.</p>
                <pre><code class="language-cpp">auto myLambda = [](int x, int y) { return x + y; };</code></pre>
            </div>
            <div class="definition">
                <h4>Capture-Klausel <code>[]</code></h4>
                <p>Der eckige Klammer-Teil eines Lambdas. Er legt fest, welche Variablen aus dem umgebenden G√ºltigkeitsbereich innerhalb des Lambdas sichtbar sind und wie sie "eingefangen" werden (als Kopie <code>[=]</code> oder als Referenz <code>[&]</code>).</p>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            
            <h3>1. Manuelle Speicherverwaltung ersetzen: `std::unique_ptr`</h3>
            <p>Anstatt `new` direkt zu verwenden, nutzen wir `std::make_unique`. Der Speicher wird automatisch freigegeben, wenn `ptr` den G√ºltigkeitsbereich verl√§sst.</p>
            <pre><code class="language-cpp">#include &lt;memory&gt; // Wichtig f√ºr Smart Pointer
#include &lt;iostream&gt;

class MyData {
public:
    MyData() { std::cout << "MyData erstellt\n"; }
    ~MyData() { std::cout << "MyData zerstoert\n"; }
    void doWork() { std::cout << "Arbeite...\n"; }
};

void useMyData() {
    // Sicher: Speicher wird garantiert freigegeben.
    std::unique_ptr&lt;MyData&gt; ptr = std::make_unique&lt;MyData&gt;();
    ptr->doWork();
} // Hier wird der Destruktor von ptr aufgerufen, der 'delete' auf dem MyData-Objekt aufruft.

int main() {
    useMyData();
    // Ausgabe zeigt, dass der Destruktor aufgerufen wurde.
}
</code></pre>

            <h3>2. Geteilten Besitz mit `std::shared_ptr` modellieren</h3>
            <p>Wenn mehrere Teile des Codes die Verantwortung f√ºr ein Objekt teilen m√ºssen, ist `shared_ptr` die richtige Wahl. Er wird mit `std::make_shared` erzeugt.</p>
            <pre><code class="language-cpp">#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

void processData(std::shared_ptr&lt;MyData&gt; p) {
    std::cout << "Use count in function: " << p.use_count() << std::endl;
    p->doWork();
} // p wird hier zerst√∂rt, der Referenzz√§hler sinkt.

int main() {
    std::shared_ptr&lt;MyData&gt; p1 = std::make_shared&lt;MyData&gt;();
    std::cout << "Use count after creation: " << p1.use_count() << std::endl; // = 1

    {
        std::shared_ptr&lt;MyData&gt; p2 = p1; // Kopieren ist erlaubt, Z√§hler wird erh√∂ht
        std::cout << "Use count after copy: " << p1.use_count() << std::endl; // = 2
    } // p2 wird hier zerst√∂rt, Z√§hler sinkt auf 1.

    processData(p1); // Tempor√§re Kopie f√ºr den Parameter, Z√§hler steigt auf 2 und sinkt wieder
    
    std::cout << "Use count before main ends: " << p1.use_count() << std::endl; // = 1
} // p1 wird hier zerst√∂rt, Z√§hler sinkt auf 0, MyData-Objekt wird gel√∂scht.
</code></pre>
            
            <h3>3. Lambda-Ausdr√ºcke mit STL-Algorithmen verwenden</h3>
            <p>Lambdas vereinfachen die Nutzung von Algorithmen, die ein "Callable" (etwas Aufrufbares) als Argument erwarten.</p>
            <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8};

    // Finde die Anzahl gerader Zahlen mit std::count_if
    int limit = 0; // Variable aus dem umgebenden Kontext
    
    int even_count = std::count_if(numbers.begin(), numbers.end(), 
        // Lambda-Ausdruck als Pr√§dikat:
        [&limit](int n) { 
            // 'limit' wurde als Referenz "gecaptured" und kann hier verwendet werden.
            return (n % 2) == 0 && n > limit;
        }
    );

    std::cout << "Anzahl gerader Zahlen: " << even_count << std::endl;
}
</code></pre>
        </section>

        <section>
            <h2>5. √úbungsaufgaben aus KE10</h2>
            <ol>
                <li>
                    <strong>Code refaktorisieren:</strong> Nehmen Sie ein √§lteres Programm (z.B. die CAD-Anwendung aus KE06), das rohe Zeiger (<code>new</code>/<code>delete</code>) verwendet, und schreiben Sie es um, sodass es stattdessen `std::unique_ptr` oder `std::shared_ptr` verwendet. Erkl√§ren Sie Ihre Wahl des jeweiligen Smart Pointers.
                </li>
                <li>
                    <strong>Lambda f√ºr Sortierung:</strong> Erstellen Sie einen `std::vector` mit Objekten einer `Person`-Klasse (mit Attributen `name` und `alter`). Verwenden Sie `std::sort` und einen Lambda-Ausdruck, um den Vektor einmal nach Namen und einmal nach Alter (absteigend) zu sortieren.
                </li>
                 <li>
                    <strong>Capture-Methoden:</strong> Schreiben Sie eine Funktion, die einen `int threshold` entgegennimmt und einen Lambda-Ausdruck zur√ºckgibt. Dieser Lambda soll ein `int` als Argument nehmen und `true` zur√ºckgeben, wenn dieses Argument gr√∂√üer als der urspr√ºngliche `threshold` ist. Welche Capture-Methode (`[=]` oder `[&]`) ist hierf√ºr sinnvoll und warum?
                </li>
            </ol>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/cpp/KE10_Utilities_V3.0.1.pdf" target="_blank">Folien √∂ffnen (PDF)</a></p>
            <p><a href="../material/cpp/Uebungen_CPP_KE10_V3.0.4.pdf" target="_blank">√úbungsblatt √∂ffnen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="kapitel-9.html">&larr; Vorheriges Kapitel</a>
  <a href="kapitel-11.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
        <p>&copy; 2025 - Dein pers√∂nlicher Programmier-Tutor</p>
    </footer>
<script src="../toggleTheme.js"></script>
</body>
</html>