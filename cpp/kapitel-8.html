<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 8: Templates</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="../c/index.html">C</a>
    <a href="index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 8: Templates</h1>
        <p>Schreiben Sie typsicheren, wiederverwendbaren Code mit der M√§chtigkeit der generischen Programmierung.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Nach dieser Einheit k√∂nnen Sie <strong>Funktions-Templates</strong> und <strong>Klassen-Templates</strong> erstellen und anwenden. Sie verstehen, wie Templates es erm√∂glichen, Algorithmen und Datenstrukturen zu definieren, die mit beliebigen Datentypen arbeiten k√∂nnen, solange diese die ben√∂tigten Operationen unterst√ºtzen. Sie kennen die Syntax mit <code>template &lt;typename T&gt;</code> und verstehen, wie der Compiler aus einem Template durch <strong>Instanziierung</strong> konkreten Code erzeugt. Sie k√∂nnen Templates mit mehreren Typ-Parametern sowie mit Nicht-Typ-Parametern (z.B. konstanten Integern) umsetzen.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Stellen Sie sich vor, Sie ben√∂tigen eine Funktion, die das Maximum zweier Werte zur√ºckgibt. Sie m√ºssten sie einmal f√ºr <code>int</code>, einmal f√ºr <code>double</code> und vielleicht noch einmal f√ºr <code>float</code> schreiben. Der Code w√§re jedes Mal praktisch identisch, nur der Datentyp w√ºrde sich √§ndern. Das ist m√ºhsam und fehleranf√§llig.
            </p>
            <p>
                √Ñhnlich verh√§lt es sich mit Datenstrukturen: Eine Klasse f√ºr einen Stapel (Stack) von <code>int</code>-Werten ist strukturell identisch mit einem Stack f√ºr <code>string</code>-Objekte. Templates l√∂sen dieses Problem elegant. Sie definieren eine Art "Schablone" f√ºr eine Funktion oder eine Klasse. Der Compiler f√ºllt diese Schablone dann bei Bedarf automatisch mit den konkreten Datentypen aus, die Sie verwenden. Die gesamte C++ Standard Template Library (STL), die wir im n√§chsten Kapitel kennenlernen, basiert auf diesem Prinzip.
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>Template (Schablone)</h4>
                <p>Eine Vorlage f√ºr eine Funktion oder Klasse in C++, die generische Programmierung erm√∂glicht. Sie definiert einen Algorithmus oder eine Datenstruktur, ohne sich auf einen bestimmten Datentyp festzulegen.</p>
            </div>
            <div class="definition">
                <h4>Funktions-Template</h4>
                <p>Eine Schablone f√ºr eine Funktion, die mit verschiedenen Datentypen arbeiten kann. Der Compiler erzeugt f√ºr jeden verwendeten Datentyp eine eigene Version der Funktion.</p>
            </div>
            <div class="definition">
                <h4>Klassen-Template</h4>
                <p>Eine Schablone f√ºr eine Klasse. Damit k√∂nnen generische Container (wie Listen, Stacks, Queues) oder andere Klassen erstellt werden, deren Member-Datentypen flexibel sind.</p>
            </div>
            <div class="definition">
                <h4>Typ-Parameter (<code>typename T</code>)</h4>
                <p>Ein Platzhalter f√ºr einen Datentyp innerhalb einer Template-Definition. <code>T</code> ist eine Konvention, jeder andere g√ºltige Bezeichner ist ebenfalls m√∂glich. <code>template &lt;class T&gt;</code> ist eine √§ltere, aber synonyme Schreibweise.</p>
            </div>
             <div class="definition">
                <h4>Instanziierung</h4>
                <p>Der Prozess, bei dem der Compiler aus einem Template (der Schablone) und einem konkreten Datentyp (z.B. <code>int</code>) eine regul√§re Funktion oder Klasse erzeugt. Dies geschieht automatisch, wenn das Template mit einem Typ verwendet wird.</p>
            </div>
             <div class="definition">
                <h4>Nicht-Typ-Parameter</h4>
                <p>Ein Template kann neben Typ-Parametern auch Parameter f√ºr konstante Werte annehmen, z.B. einen Integer, um die Gr√∂√üe eines Arrays zur Compile-Zeit festzulegen.</p>
                <pre><code class="language-cpp">template &lt;typename T, int SIZE&gt; class MyArray { /* ... */ };</code></pre>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            
            <h3>1. Ein Funktions-Template erstellen</h3>
            <p>Die Definition beginnt mit <code>template &lt;typename T&gt;</code>. Danach folgt die Funktionsdefinition, wobei <code>T</code> als Platzhalter f√ºr den Datentyp verwendet wird.</p>
            <pre><code class="language-cpp">// Ein Template f√ºr eine 'swap'-Funktion
#include &lt;iostream&gt;

template &lt;typename T&gt;
void swap_values(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int i = 5, j = 10;
    swap_values(i, j); // Compiler instanziiert swap_values&lt;int&gt;
    std::cout << "i: " << i << ", j: " << j << std::endl;

    double x = 3.14, y = 2.71;
    swap_values(x, y); // Compiler instanziiert swap_values&lt;double&gt;
    std::cout << "x: " << x << ", y: " << y << std::endl;
}
</code></pre>

            <h3>2. Ein Klassen-Template erstellen</h3>
            <p>Analog zu Funktions-Templates wird die Klassendefinition mit <code>template &lt;...&gt;</code> eingeleitet. Wichtig: Bei der Definition von Methoden au√üerhalb der Klassendeklaration muss die Template-Signatur wiederholt werden.</p>
            <pre><code class="language-cpp">// Pair.h - Eine Klasse, die ein Paar von Werten speichern kann
template &lt;typename T1, typename T2&gt; // Template mit zwei Typ-Parametern
class Pair {
private:
    T1 first_;
    T2 second_;
public:
    Pair(const T1& first, const T2& second);
    T1 getFirst() const;
    void setFirst(const T1& value);
    // ... Methoden f√ºr second_
};

// Wichtig: Template-Signatur bei externer Definition wiederholen
template &lt;typename T1, typename T2&gt;
Pair&lt;T1, T2&gt;::Pair(const T1& first, const T2& second) 
: first_(first), second_(second) {}

template &lt;typename T1, typename T2&gt;
T1 Pair&lt;T1, T2&gt;::getFirst() const {
    return first_;
}

// ...
</code></pre>
            
            <h3>3. Ein Klassen-Template verwenden</h3>
            <p>Bei der Instanziierung eines Klassen-Templates m√ºssen die konkreten Typen in spitzen Klammern angegeben werden.</p>
            <pre><code class="language-cpp">#include "Pair.h"
#include &lt;string&gt;

int main() {
    // Instanziiere ein Paar aus int und double
    Pair&lt;int, double&gt; p1(1, 3.14);
    
    // Instanziiere ein Paar aus string und bool
    Pair&lt;std::string, bool&gt; p2("Test", true);
    
    std::cout << p1.getFirst() << std::endl;
    std::cout << p2.getFirst() << std::endl;
}
</code></pre>
            <p><strong>Wichtiger Hinweis:</strong> Die Implementierung von Templates (sowohl Deklaration als auch Definition) geh√∂rt in der Regel komplett in die Header-Datei. Da der Compiler zur Instanziierung den gesamten Code der Schablone ben√∂tigt, w√ºrde ein traditionelles Trennen in .h und .cpp zu Linker-Fehlern f√ºhren.</p>
        </section>

        <section>
            <h2>5. √úbungsaufgaben aus KE08</h2>
            <ol>
                <li>
                    <strong>Generische `max()`-Funktion:</strong> Schreiben Sie ein Funktions-Template f√ºr eine Funktion `max`, die zwei Argumente eines beliebigen Typs entgegennimmt und das gr√∂√üere der beiden zur√ºckgibt. Testen Sie Ihre Funktion mit <code>int</code>, <code>double</code> und <code>std::string</code>. Welche Voraussetzung muss der Datentyp <code>T</code> erf√ºllen, damit der Code kompiliert? (Antwort: Der `>`-Operator muss f√ºr den Typ definiert sein).
                </li>
                <li>
                    <strong>Generischer Stack:</strong> Implementieren Sie ein Klassen-Template f√ºr eine `Stack`-Klasse. Der Stack soll intern ein Array zur Speicherung der Elemente nutzen. Verwenden Sie einen Nicht-Typ-Parameter f√ºr die Gr√∂√üe des Arrays (z.B. <code>template &lt;typename T, int MAX_SIZE&gt; class Stack</code>). Die Klasse soll Methoden wie `push()`, `pop()`, `top()` und `isEmpty()` haben.
                </li>
                 <li>
                    <strong>Typen explizit angeben:</strong> Schreiben Sie ein Funktions-Template, das einen Wert eines Typs `T` entgegennimmt und ihn in einen Typ `U` umwandelt und zur√ºckgibt. (<code>template &lt;typename U, typename T&gt; U convert(const T& value)</code>). Warum muss man beim Aufruf dieser Funktion die Typ-Parameter explizit angeben (z.B. <code>convert&lt;int, double&gt;(5.5)</code>), w√§hrend es bei der `swap_values`-Funktion nicht n√∂tig war?
                </li>
            </ol>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/cpp/KE08_Templates_V3.0.1.pdf" download>Folien herunterladen (PDF)</a></p>
            <p><a href="../material/cpp/Uebungen_CPP_KE08_V3.0.4.pdf" download>√úbungsblatt herunterladen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="kapitel-7.html">&larr; Vorheriges Kapitel</a>
  <a href="kapitel-9.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
        <p>&copy; 2025 - Dein pers√∂nlicher Programmier-Tutor</p>
    </footer>
<script src="../toggleTheme.js"></script>
</body>
</html>