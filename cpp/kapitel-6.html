<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 6: Polymorphie und virtuelle Funktionen</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="../c/index.html">C</a>
    <a href="index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 6: Polymorphie und virtuelle Funktionen</h1>
        <p>Schreiben Sie flexiblen Code, der mit einer ganzen Familie von verwandten Objekten umgehen kann, ohne deren genauen Typ zu kennen.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Nach der Bearbeitung dieser Einheit beherrschen Sie das Konzept des <strong>dynamischen Polymorphismus</strong> in C++. Sie k√∂nnen Methoden mithilfe des Schl√ºsselworts <strong><code>virtual</code></strong> als √ºberschreibbar deklarieren. Sie wissen, wie man <strong>abstrakte Klassen</strong> mit rein virtuellen Funktionen (<code>= 0</code>) erstellt, um Interfaces zu definieren. Des Weiteren verstehen Sie die zwingende Notwendigkeit von <strong>virtuellen Destruktoren</strong> bei der Arbeit mit Klassenhierarchien und dynamischem Speicher. Sie k√∂nnen Methoden mit dem <code>override</code>-Spezifizierer sicher √ºberschreiben und das Liskovsche Substitutionsprinzip in der Praxis anwenden.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Stellen Sie sich eine Grafikanwendung vor. Sie haben eine Vielzahl von geometrischen Formen: <code>Kreis</code>, <code>Rechteck</code>, <code>Dreieck</code>, <code>Polygon</code> usw. Sie m√∂chten alle diese Formen in einer einzigen Liste speichern und sie mit einer einfachen Schleife zeichnen, etwa so: <code>for (auto form : alleFormen) { form.zeichne(); }</code>.
            </p>
            <p>
                Ohne Polymorphismus w√§re das unm√∂glich, da die Liste Objekte unterschiedlicher Typen enthalten m√ºsste. Der Polymorphismus ("Vielgestaltigkeit") erlaubt es uns, eine Liste von Zeigern auf eine gemeinsame Basisklasse (z.B. <code>Form*</code>) zu verwalten. Wenn wir dann die Methode <code>zeichne()</code> √ºber einen solchen Zeiger aufrufen, sorgt C++ zur Laufzeit daf√ºr, dass die korrekte, spezifische <code>zeichne()</code>-Methode (die des Kreises, die des Rechtecks etc.) ausgef√ºhrt wird. Diesen Mechanismus nennt man <strong>dynamische Bindung</strong> (Late Binding) und er ist der Schl√ºssel zu flexiblen und leicht erweiterbaren Systemen.
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>Dynamischer Polymorphismus</h4>
                <p>Die F√§higkeit eines Programms, zur Laufzeit zu entscheiden, welche von mehreren gleichnamigen Methoden in einer Klassenhierarchie aufgerufen wird. Die Entscheidung basiert auf dem tats√§chlichen Typ des Objekts, auf das ein Basisklassen-Zeiger oder eine -Referenz verweist.</p>
            </div>
            <div class="definition">
                <h4>Virtuelle Funktion (<code>virtual</code>)</h4>
                <p>Eine Memberfunktion, die in einer Basisklasse mit dem Schl√ºsselwort <code>virtual</code> deklariert wird. Dies signalisiert dem Compiler, dass die Methode in abgeleiteten Klassen √ºberschrieben werden kann und Aufrufe √ºber Basisklassen-Zeiger/-Referenzen dynamisch gebunden werden sollen.</p>
            </div>
             <div class="definition">
                <h4>√úberschreiben (<code>override</code>)</h4>
                <p>Eine Methode in einer abgeleiteten Klasse implementiert eine virtuelle Methode der Basisklasse neu. Die Signatur (Name, Parameter, const-Modifizierer) muss exakt √ºbereinstimmen. Der optionale, aber empfohlene Spezifizierer <code>override</code> pr√ºft dies zur Compile-Zeit.</p>
            </div>
            <div class="definition">
                <h4>Abstrakte Klasse</h4>
                <p>Eine Klasse, von der keine Objekte instanziiert werden k√∂nnen. Sie dient als Vorlage f√ºr abgeleitete Klassen. Eine Klasse wird abstrakt, sobald sie mindestens eine rein virtuelle Funktion enth√§lt.</p>
            </div>
            <div class="definition">
                <h4>Rein Virtuelle Funktion (Pure Virtual Function)</h4>
                <p>Eine virtuelle Funktion, die in der Basisklasse nur deklariert, aber nicht implementiert wird, indem man ihr <code>= 0;</code> anf√ºgt. Jede nicht-abstrakte abgeleitete Klasse ist gezwungen, diese Funktion zu implementieren.</p>
                <pre><code class="language-cpp">virtual void zeichne() const = 0;</code></pre>
            </div>
            <div class="definition">
                <h4>Virtueller Destruktor</h4>
                <p>Ein Destruktor in einer Basisklasse, der als <code>virtual</code> deklariert ist. Dies stellt sicher, dass beim L√∂schen eines abgeleiteten Objekts √ºber einen Basisklassen-Zeiger der korrekte Destruktor (erst der der Kindklasse, dann der der Basisklasse) aufgerufen wird, um Speicherlecks zu vermeiden.</p>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            
            <h3>1. Polymorphismus erm√∂glichen: `virtual`</h3>
            <p>Um die dynamische Bindung zu aktivieren, muss die Methode in der Basisklasse als <code>virtual</code> gekennzeichnet sein. Alle abgeleiteten Klassen, die diese Methode neu implementieren, √ºberschreiben sie dann.</p>
            <pre><code class="language-cpp">class Tier {
public:
    // virtual aktiviert den Polymorphismus f√ºr diese Funktion
    virtual void lautGeben() const { 
        std::cout << "Ein Tier macht einen Laut." << std::endl; 
    }
    // Wichtig: Virtueller Destruktor!
    virtual ~Tier() {}
};

class Hund : public Tier {
public:
    // √úberschreiben der virtuellen Funktion. 'override' ist guter Stil.
    void lautGeben() const override {
        std::cout << "Wuff!" << std::endl;
    }
};
</code></pre>

            <h3>2. Polymorphie anwenden</h3>
            <p>Polymorphismus funktioniert nur √ºber <strong>Zeiger oder Referenzen</strong> auf die Basisklasse.</p>
            <pre><code class="language-cpp">Tier* pTier1 = new Hund();
Tier* pTier2 = new Katze(); // Angenommen, Katze existiert auch

pTier1->lautGeben(); // Gibt "Wuff!" aus
pTier2->lautGeben(); // Gibt "Miau!" aus

// Wichtig: Speicher freigeben!
delete pTier1; 
delete pTier2;
</code></pre>
            <p>Ohne <code>virtual</code> in `Tier::lautGeben()` w√ºrden beide Aufrufe die Methode der Basisklasse (`Tier`) ausf√ºhren, da die Entscheidung statisch zur Compile-Zeit getroffen w√ºrde.</p>
            
            <h3>3. Abstrakte Klassen als "Vertr√§ge" nutzen</h3>
            <p>Oft will man gar kein Objekt der Basisklasse (z.B. `Form`) erstellen, sondern sie nur als Schablone ("Interface") nutzen. Dies erreicht man durch rein virtuelle Funktionen.</p>
            <pre><code class="language-cpp">// Eine abstrakte Klasse "Form"
class Form {
public:
    // Rein virtuelle Funktion: Jede konkrete Form MUSS dies implementieren.
    virtual double berechneFlaeche() const = 0; 
    
    virtual ~Form() = default; // Der Destruktor muss implementiert sein
};

class Kreis : public Form {
private: 
    double radius_;
public:
    Kreis(double r) : radius_(r) {}
    // Kreis MUSS berechneFlaeche implementieren, sonst ist er auch abstrakt.
    double berechneFlaeche() const override {
        return 3.14159 * radius_ * radius_;
    }
};

int main() {
    // Form f; // FEHLER: Form ist eine abstrakte Klasse.
    Form* pForm = new Kreis(10.0); // OK
    std::cout << "Flaeche: " << pForm->berechneFlaeche() << std::endl;
    delete pForm;
}
</code></pre>
        </section>

        <section>
            <h2>5. Wichtiger Sonderfall: Der virtuelle Destruktor</h2>
            <p><strong>Regel:</strong> Jede Klasse, die mindestens eine virtuelle Funktion besitzt, sollte auch einen virtuellen Destruktor haben.</p>
            <p>Wird ein abgeleitetes Objekt, das dynamisch erzeugt wurde, √ºber einen Basisklassen-Zeiger gel√∂scht, wird ohne virtuellen Destruktor nur der Destruktor der Basisklasse aufgerufen. Ressourcen, die im Destruktor der abgeleiteten Klasse freigegeben werden m√ºssten (z.B. Speicher, Dateien), gehen verloren. Dies f√ºhrt zu Speicherlecks und undefiniertem Verhalten.</p>
             <pre><code class="language-cpp">// FALSCH:
class Base { public: ~Base() { /* ... */ } };
class Derived : public Base { private: int* p_; public: Derived() {p_ = new int[100];} ~Derived() {delete[] p_;} };
Base* b = new Derived();
delete b; // Ruft NUR ~Base() auf. Die 100 ints werden NICHT freigegeben!

// RICHTIG:
class Base { public: virtual ~Base() { /* ... */ } };
class Derived : public Base { private: int* p_; public: Derived() {p_ = new int[100];} ~Derived() {delete[] p_;} };
Base* b = new Derived();
delete b; // Ruft ~Derived() und DANACH ~Base() auf. Alles korrekt.
</code></pre>
        </section>

        <section>
            <h2>6. √úbungsaufgaben aus KE06</h2>
            <ol>
                <li>
                    <strong>CAD-Programm:</strong> Implementieren Sie die Klassenhierarchie aus √úbung 1. Erstellen Sie eine abstrakte Basisklasse `Shape` mit einer rein virtuellen Methode `vDraw()`. Leiten Sie davon `Point`, `Circle` und `Rectangle` ab. Erstellen Sie eine Klasse `CAD_Drawing`, die in einem `std::set` eine Sammlung von `Shape*` verwalten kann. Die `vDrawIt()`-Methode von `CAD_Drawing` soll dann √ºber alle Formen iterieren und deren jeweilige `vDraw()`-Methode aufrufen.
                </li>
                <li>
                    <strong>Speicherleck finden:</strong> Analysieren Sie ein Codebeispiel, das ein Speicherleck aufgrund eines fehlenden virtuellen Destruktors enth√§lt. Erkl√§ren Sie genau, warum der Speicher nicht freigegeben wird. Korrigieren Sie den Code.
                </li>
                 <li>
                    <strong>Liskovsches Substitutionsprinzip:</strong> Erkl√§ren Sie anhand eines Beispiels, warum eine Funktion, die eine Referenz auf eine Basisklasse erwartet (z.B. <code>void process(Base& b)</code>), problemlos mit einem Objekt einer abgeleiteten Klasse aufgerufen werden kann. Warum funktioniert der umgekehrte Weg nicht?
                </li>
            </ol>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/cpp/KE06_Vererbung_2_V3.0.1.pdf" target="_blank">Folien √∂ffnen (PDF)</a></p>
            <p><a href="../material/cpp/Uebungen_CPP_KE06_V3.0.4.pdf" target="_blank">√úbungsblatt √∂ffnen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="kapitel-5.html">&larr; Vorheriges Kapitel</a>
  <a href="kapitel-7.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
        <p>&copy; 2025 - Dein pers√∂nlicher Programmier-Tutor</p>
    </footer>
<script src="../toggleTheme.js"></script>
</body>
</html>