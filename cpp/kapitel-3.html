<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 3: Ressourcenmanagement & Kopiersemantik</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="../c/index.html">C</a>
    <a href="index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 3: Ressourcenmanagement & Kopiersemantik</h1>
        <p>Eigene Klassen intuitiv bedienbar machen und Speicher sicher verwalten.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Nach dieser Einheit verstehst du, wie man das Verhalten von C++-Operatoren (wie <code>+</code>, <code>=</code>, <code>&lt;&lt;</code>) f√ºr eigene Klassen durch <strong>Operator√ºberladung</strong> anpasst. Du kennst die "Regel der Drei" und kannst <strong>Kopierkonstruktor</strong>, <strong>Zuweisungsoperator</strong> und <strong>Destruktor</strong> implementieren, um dynamische Ressourcen korrekt zu verwalten und den Unterschied zwischen einer flachen und einer tiefen Kopie zu meistern.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Warum sollten wir `obj3 = obj1 + obj2;` nicht schreiben k√∂nnen, wenn es f√ºr `int`s funktioniert? Die Operator√ºberladung erlaubt es uns, unseren eigenen Klassen ein ebenso intuitives Verhalten zu geben wie den eingebauten Datentypen. Wir k√∂nnen definieren, was es bedeutet, zwei `Complex`-Objekte zu addieren oder ein `Date`-Objekt mit `std::cout` auszugeben.
            </p>
            <p>
                Gleichzeitig sto√üen die vom Compiler generierten Standard-Methoden an ihre Grenzen, sobald unsere Klasse dynamischen Speicher (z.B. mit `new`) verwaltet. Die Standardkopie ist eine "flache Kopie", die nur den Zeigerwert kopiert, nicht aber die Daten, auf die gezeigt wird. Dies f√ºhrt zu schwerwiegenden Fehlern. Das korrekte Management dieser Ressourcen √ºber die "Regel der Drei" ist eine der fundamentalen Techniken f√ºr robuste C++-Programme.
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>Operator√ºberladung</h4>
                <p>Die M√∂glichkeit, die Bedeutung eines Operators f√ºr einen benutzerdefinierten Typ (eine Klasse) neu zu definieren. Die Funktion, die dies implementiert, wird mit dem Schl√ºsselwort <code>operator</code> gefolgt vom Operator-Symbol deklariert (z.B. <code>operator+</code>).</p>
            </div>
            <div class="definition">
                <h4>Kopierkonstruktor</h4>
                <p>Ein Konstruktor, der ein neues Objekt als Kopie eines bereits existierenden Objekts derselben Klasse erzeugt. Seine Signatur ist typischerweise <code>ClassName(const ClassName& other);</code>.</p>
            </div>
            <div class="definition">
                <h4>Zuweisungsoperator</h4>
                <p>Ein √ºberladener Operator (<code>operator=</code>), der einem bereits existierenden Objekt den Zustand eines anderen Objekts zuweist. Seine Signatur ist typischerweise <code>ClassName& operator=(const ClassName& other);</code>.</p>
            </div>
            <div class="definition">
                <h4>Flache vs. Tiefe Kopie (Shallow vs. Deep Copy)</h4>
                <ul>
                    <li><strong>Flache Kopie:</strong> Eine bitweise Kopie der Membervariablen. Wenn ein Member ein Zeiger ist, wird nur die Adresse kopiert, nicht die dahinterliegenden Daten. Beide Objekte zeigen danach auf denselben Speicher.</li>
                    <li><strong>Tiefe Kopie:</strong> Erstellt eine vollst√§ndige, unabh√§ngige Kopie. Wenn ein Member ein Zeiger ist, wird neuer Speicher allokiert und die Daten, auf die der Originalzeiger zeigt, werden in den neuen Speicher kopiert.</li>
                </ul>
            </div>
            <div class="definition">
                <h4>Die Regel der Drei (Rule of Three)</h4>
                <p>Eine C++-Daumenregel, die besagt: Wenn eine Klasse einen der folgenden drei Member explizit ben√∂tigt, ben√∂tigt sie wahrscheinlich alle drei: Destruktor, Kopierkonstruktor, Zuweisungsoperator.</p>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            <h3>1. Das Problem: Die flache Kopie</h3>
            <p>Der vom Compiler generierte Kopierkonstruktor und Zuweisungsoperator sind f√ºr Klassen mit Zeigern gef√§hrlich.</p>
            <pre><code>class MyString {
private:
    char* data_;
public:
    // ...
};

MyString s1("Hello");
MyString s2 = s1; // Kopierkonstruktor: s2.data_ zeigt jetzt auf dieselbe Adresse wie s1.data_!
// Wenn s2 zerst√∂rt wird, wird der Speicher von "Hello" freigegeben.
// s1 zeigt jetzt auf ung√ºltigen Speicher (Dangling Pointer)!
</code></pre>

            <h3>2. Die L√∂sung: Die Regel der Drei implementieren</h3>
            <p>Um das Problem zu l√∂sen, m√ºssen wir die drei speziellen Member-Funktionen selbst schreiben, um eine tiefe Kopie zu gew√§hrleisten.</p>
            <pre><code>// In der Klassendefinition (z.B. MyString.h)
public:
    ~MyString(); // 1. Destruktor
    MyString(const MyString& other); // 2. Kopierkonstruktor
    MyString& operator=(const MyString& other); // 3. Zuweisungsoperator

// Implementierung (z.B. MyString.cpp)
// 1. Destruktor: Gibt den Speicher frei
MyString::~MyString() { delete[] data_; }

// 2. Kopierkonstruktor: Allokiert neuen Speicher und kopiert den Inhalt
MyString::MyString(const MyString& other) {
    size_t len = strlen(other.data_) + 1;
    data_ = new char[len];
    strcpy_s(data_, len, other.data_);
}

// 3. Zuweisungsoperator: Gibt alten Speicher frei, allokiert neuen, kopiert Inhalt
MyString& MyString::operator=(const MyString& other) {
    if (this != &other) { // Wichtig: Selbstzuweisung verhindern!
        delete[] data_; // Alten Speicher freigeben
        size_t len = strlen(other.data_) + 1;
        data_ = new char[len];
        strcpy_s(data_, len, other.data_);
    }
    return *this; // Referenz auf sich selbst zur√ºckgeben
}
</code></pre>
            
            <h3>3. Operatoren √ºberladen</h3>
            <p>Um z.B. `std::cout << myObject;` zu erm√∂glichen, √ºberl√§dt man den `<<`-Operator. Da der Stream `std::cout` links vom Operator steht, kann dies keine Member-Funktion sein. Man verwendet eine globale `friend`-Funktion.</p>
            <pre><code>// In der Klassendeklaration (z.B. Complex.h)
class Complex {
    // ...
    // friend deklarieren, damit die Funktion auf private Member zugreifen kann
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
private:
    double real_, imag_;
};

// Globale Implementierung (z.B. Complex.cpp)
std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << c.real_ << " + j(" << c.imag_ << ")";
    return os;
}
</code></pre>
        </section>

        <section>
             <h2>5. Beispielprogramm 1: Komplexe Zahlen addieren</h2>
             <p>Wir erweitern die `Complex`-Klasse aus dem letzten Kapitel um einen √ºberladenen `+`-Operator, um `z3 = z1 + z2;` zu erm√∂glichen.</p>
            <pre><code>// In Complex.h (innerhalb der Klassendeklaration)
public:
    Complex operator+(const Complex& other) const;

// In Complex.cpp
Complex Complex::operator+(const Complex& other) const {
    // Erzeuge ein neues Complex-Objekt mit den summierten Werten
    return Complex(this->f64Real_ + other.f64Real_, this->f64Img_ + other.f64Img_);
}

// In main.cpp
MyMath::Complex z1(3.0, 4.0);
MyMath::Complex z2(1.0, -2.0);
MyMath::Complex z3 = z1 + z2; // Ruft z1.operator+(z2) auf
z3.vPrint(); // Gibt "4 + j(2)" aus
</code></pre>
        </section>

        <section>
            <h2>6. √úbungsaufgaben</h2>
            <ol>
                <li><strong>`Complex`-Subtraktion:</strong> √úberlade den `-`-Operator f√ºr deine `Complex`-Klasse als Member-Funktion.</li>
                <li><strong>`Complex`-Ausgabe:</strong> Implementiere den `<<`-Operator f√ºr `std::cout` f√ºr deine `Complex`-Klasse als `friend`-Funktion, wie oben im Beispiel gezeigt.</li>
                <li><strong>Pre-Inkrement f√ºr `Counter`:</strong> Nimm die `Counter`-Klasse aus dem letzten Kapitel. √úberlade den Pre-Inkrement-Operator (`++c`), sodass er den internen Wert erh√∂ht und eine Referenz auf das Objekt zur√ºckgibt. Die Signatur lautet: `Counter& operator++();`.</li>
                <li><strong>Deep Copy f√ºr eine `Playlist`:</strong> Erstelle eine Klasse `Playlist`, die als privates Attribut einen dynamisch allokierten Zeiger auf ein Array von `std::string`s enth√§lt (`std::string* tracks_;`). Implementiere die "Regel der Drei" (Destruktor, Kopierkonstruktor, Zuweisungsoperator), um eine korrekte tiefe Kopie zu gew√§hrleisten.</li>
            </ol>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/cpp/KE03_Klassen_2_V3.0.1.pdf" download>Folien herunterladen (PDF)</a></p>
            <p><a href="../material/cpp/Uebungen_CPP_KE03_V3.0.7.pdf" download>√úbungsblatt herunterladen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="kapitel-2.html">&larr; Vorheriges Kapitel</a>
  <a href="kapitel-4.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
    </footer>
<script src="../toggleTheme.js"></script>
</body>
</html>