<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kapitel 9: Die Standard Template Library (STL)</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
<nav id="main-nav">
    <a href="../index.html">Start</a>
    <a href="../c/index.html">C</a>
    <a href="index.html">C++</a>
    <a href="../material/index.html">Materialien</a>
    <button id="theme-toggle" aria-label="Theme umschalten">üåì</button>
</nav>

    <header>
        <h1>Kapitel 9: Die Standard Template Library (STL)</h1>
        <p>Nutzen Sie die m√§chtigen und effizienten Container, Iteratoren und Algorithmen der C++ Standardbibliothek.</p>
    </header>

    <main>
        <section>
            <h2>1. Lernziel</h2>
            <p>
                Nach dieser Einheit kennen Sie die drei fundamentalen S√§ulen der STL: <strong>Container</strong>, <strong>Iteratoren</strong> und <strong>Algorithmen</strong>. Sie k√∂nnen die wichtigsten sequentiellen Container (<code>std::vector</code>, <code>std::list</code>, <code>std::deque</code>) und assoziativen Container (<code>std::map</code>, <code>std::set</code>) anwenden und deren grundlegende Eigenschaften und Leistungscharakteristiken unterscheiden. Sie verstehen, wie <strong>Iteratoren</strong> als vereinheitlichte Schnittstelle zum Durchlaufen von Containern dienen. Sie k√∂nnen die gebr√§uchlichsten <strong>Algorithmen</strong> der STL (z.B. <code>sort</code>, <code>find</code>, <code>for_each</code>, <code>count_if</code>) auf Container anwenden, um komplexe Operationen mit minimalem Code-Aufwand durchzuf√ºhren.
            </p>
        </section>

        <section>
            <h2>2. Motivation & Kontext</h2>
            <p>
                Warum sollte man das Rad neu erfinden? Anstatt grundlegende Datenstrukturen wie dynamische Arrays, verkettete Listen oder Suchb√§ume jedes Mal selbst zu implementieren, stellt C++ die Standard Template Library (STL) zur Verf√ºgung. Diese ist eine Sammlung von extrem effizienten, robusten und intensiv getesteten Template-Klassen und -Funktionen.
            </p>
            <p>
                Die Genialit√§t der STL liegt in ihrem Design: Container (die Daten speichern), Algorithmen (die Daten verarbeiten) und Iteratoren (die als Bindeglied zwischen beiden fungieren) sind voneinander entkoppelt. Das bedeutet, Sie k√∂nnen denselben Sortier-Algorithmus auf ein Array, eine Liste oder einen anderen Containertyp anwenden. Die Verwendung der STL f√ºhrt zu k√ºrzerem, sichereren, schnelleren und besser lesbarem Code. Die Kenntnis der STL ist f√ºr jeden C++-Programmierer unerl√§sslich.
            </p>
        </section>

        <section>
            <h2>3. Definitionen & Begriffe</h2>
            <div class="definition">
                <h4>Container</h4>
                <p>Objekte, die andere Objekte verwalten und speichern. Man unterscheidet haupts√§chlich zwischen sequentiellen Containern (z.B. <code>vector</code>, <code>list</code>) und assoziativen Containern (z.B. <code>map</code>, <code>set</code>).</p>
            </div>
            <div class="definition">
                <h4><code>std::vector</code></h4>
                <p>Ein dynamisches Array. Speichert Elemente zusammenh√§ngend im Speicher. Erlaubt sehr schnellen wahlfreien Zugriff (<code>v[i]</code>), aber langsames Einf√ºgen/L√∂schen in der Mitte.</p>
            </div>
             <div class="definition">
                <h4><code>std::list</code></h4>
                <p>Eine doppelt verkettete Liste. Speichert Elemente verstreut im Speicher. Erlaubt sehr schnelles Einf√ºgen/L√∂schen an beliebiger Stelle, aber nur langsamen sequentiellen Zugriff.</p>
            </div>
            <div class="definition">
                <h4><code>std::map</code></h4>
                <p>Ein assoziativer Container, der Schl√ºssel-Wert-Paare (key-value) speichert. Die Elemente sind nach dem Schl√ºssel sortiert. Erm√∂glicht sehr schnelles Suchen, Einf√ºgen und L√∂schen basierend auf dem Schl√ºssel.</p>
            </div>
            <div class="definition">
                <h4>Iterator</h4>
                <p>Ein "verallgemeinerter Zeiger", der auf ein Element in einem Container zeigt. Iteratoren erm√∂glichen es, durch einen Container zu "laufen" (iterieren) und stellen die Verbindung zu den Algorithmen her. Jeder Container stellt Typen wie <code>begin()</code> und <code>end()</code> bereit, um Iteratoren auf das erste Element bzw. "hinter" das letzte Element zu erhalten.</p>
            </div>
            <div class="definition">
                <h4>Algorithmus</h4>
                <p>Eine Template-Funktion, die Operationen auf einem Bereich von Elementen ausf√ºhrt. Der Bereich wird durch zwei Iteratoren (Anfang und Ende) definiert. Beispiele sind <code>std::sort</code>, <code>std::find</code>, <code>std::copy</code>.</p>
            </div>
        </section>

        <section>
            <h2>4. Schritt-f√ºr-Schritt-Erkl√§rung</h2>
            
            <h3>1. Einen `std::vector` verwenden</h3>
            <p>Der `vector` ist der am h√§ufigsten verwendete Container. Er ist flexibel und effizient f√ºr die meisten Anwendungsf√§lle.</p>
            <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main() {
    // Ein Vektor von Strings
    std::vector&lt;std::string&gt; names;

    // Elemente hinzuf√ºgen
    names.push_back("Alice");
    names.push_back("Bob");
    names.push_back("Charlie");

    // Auf Elemente zugreifen
    std::cout << "Erster Name: " << names[0] << std::endl;
    
    // Durch einen Vektor mit einem range-based for-loop iterieren (bevorzugt)
    for (const std::string& name : names) {
        std::cout << name << std::endl;
    }
}
</code></pre>

            <h3>2. Mit Iteratoren und Algorithmen arbeiten</h3>
            <p>Algorithmen operieren auf Iterator-Paaren. <code>begin()</code> zeigt auf das erste Element, <code>end()</code> zeigt auf die Position *nach* dem letzten Element.</p>
            <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt; // Wichtig f√ºr die Algorithmen!
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {10, 5, 8, 2, 9};

    // Finde ein Element
    // std::find gibt einen Iterator auf das gefundene Element oder numbers.end() zur√ºck
    auto it = std::find(numbers.begin(), numbers.end(), 8);

    if (it != numbers.end()) {
        std::cout << "Element 8 gefunden!" << std::endl;
    }

    // Sortiere den Vektor
    std::sort(numbers.begin(), numbers.end()); // Sortiert von {10, 5, ...} zu {2, 5, ...}

    // Gib den sortierten Vektor aus
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}
</code></pre>
            
            <h3>3. Eine `std::map` f√ºr Schl√ºssel-Wert-Paare verwenden</h3>
            <p>Eine Map ist ideal, um Daten √ºber einen eindeutigen Schl√ºssel schnell nachzuschlagen.</p>
            <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main() {
    // Eine Map von Namen (string) zu Telefonnummern (int)
    std::map&lt;std::string, int&gt; phonebook;

    // Eintr√§ge hinzuf√ºgen
    phonebook["Alice"] = 12345;
    phonebook["Bob"] = 67890;
    phonebook.insert(std::make_pair("Charlie", 54321));

    // Einen Wert nachschlagen
    std::cout << "Bobs Nummer: " << phonebook["Bob"] << std::endl;

    // Durch eine Map iterieren
    for (const auto& pair : phonebook) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
}
</code></pre>
        </section>

        <section>
            <h2>5. √úbungsaufgaben aus KE09</h2>
            <ol>
                <li>
                    <strong>`vector` vs. `list`:</strong> Erstellen Sie einen `std::vector` und eine `std::list` mit 1 Million Zufallszahlen. Messen Sie die Zeit, die ben√∂tigt wird, um 1000 Zahlen in der Mitte des Containers einzuf√ºgen. Messen Sie danach die Zeit, um 1000-mal auf ein zuf√§lliges Element zuzugreifen. Vergleichen und erkl√§ren Sie die Ergebnisse.
                </li>
                <li>
                    <strong>Telefonbuch mit `map`:</strong> Implementieren Sie ein einfaches Telefonbuch-Programm mit einer `std::map&lt;std::string, std::string&gt;`. Das Programm soll es dem Benutzer erm√∂glichen, neue Eintr√§ge hinzuzuf√ºgen, eine Nummer zu einem gegebenen Namen zu suchen und alle Eintr√§ge auszugeben.
                </li>
                 <li>
                    <strong>Algorithmen anwenden:</strong> Erstellen Sie einen `std::vector` mit Objekten einer eigenen Klasse (z.B. `Student` mit Name und Matrikelnummer).
                    <ul>
                        <li>Verwenden Sie <code>std::sort</code> mit einer Lambda-Funktion, um die Studenten nach Matrikelnummer zu sortieren.</li>
                        <li>Verwenden Sie <code>std::find_if</code>, um den ersten Studenten mit einer bestimmten Eigenschaft zu finden.</li>
                        <li>Verwenden Sie <code>std::count_if</code>, um zu z√§hlen, wie viele Studenten eine Bedingung erf√ºllen (z.B. eine bessere Note als 2.0 haben).</li>
                    </ul>
                </li>
            </ol>
        </section>
        <section>
            <h2>Material</h2>
            <p><a href="../material/cpp/KE09_STL_V3.0.1.pdf" target="_blank">Folien √∂ffnen (PDF)</a></p>
            <p><a href="../material/cpp/Uebungen_CPP_KE09_V3.0.4.pdf" target="_blank">√úbungsblatt √∂ffnen (PDF)</a></p>
        </section>
    </main>

    <footer>
<nav class="chapter-nav">
  <a href="kapitel-8.html">&larr; Vorheriges Kapitel</a>
  <a href="kapitel-10.html">N√§chstes Kapitel &rarr;</a>
</nav>
<p><a href="../index.html">&larr; Zur√ºck zur √úbersicht</a></p>
        <p>&copy; 2025 - Dein pers√∂nlicher Programmier-Tutor</p>
    </footer>
<script src="../toggleTheme.js"></script>
</body>
</html>